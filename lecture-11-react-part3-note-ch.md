# Lecture 11 React Part 3

## 本节课-核心重点
- 写代码方式方法 
	- 好的代码写三遍
	- 一个能工作的代码是最小的要求，在其之上要不断地反思扣细节
- 学习的方式方法
	- 真正写代码时候，会有东西不断地告诉你去学习
	- 当你有一天不得不用，就必须要去学习更多的东西，项目 error driven



符合人类思考方式来**抽象**。

Single Responsibility:脑子自然而然想到“这是一个单独的事情”，是不是一个单独的责任。比如说出门开车门

出门前找钥匙，是完全可以单独存在的。
开车门和开车不是一个糅合在一起的逻辑，因为你开车门可能是可以拿东西，而不是去开车。

![](https://i.imgur.com/DuPGqRK.png)

挂档和给油是不需要抽象，因为它本身就是一件事

![](https://i.imgur.com/MkUVwSs.png)


junior有一定的思维定势，给代码语言和编程绑架了，过度抽象。如果还不能写符合人类的思维方式，就得按照solid原则来约束自己。

![](https://i.imgur.com/a5crXFH.png)


一个死循环：因为没有找到工作，就没办法写到大量代码，因为没有大量代码，就没办法在商业环境里来训练SOLID。

由于在学校写school project，根本不关心code quality，只关心能不能工作，导致许多人一毕业就失业。

即便参加一些开源项目，也没有context。可能看到写一些好的代码，也没有办法与其他人以同等高度去看待代码。

必须要正儿八级的it公司，code quality是工作的中心

现在要开始写代码，然后问龙哥

在澳洲找工作的敲门砖，但是你是没办法找到的
从澳洲graduate能找到工作，唯独中国人找不到工作

需要写代码才能够练习


技巧一：伟大中国人民族品德- humble，常自我否定。

在大前提是[你不会，或者你没有掌握按照人类的思维写代码（solid)]，自己写的第一遍代码不会是一个好的代码。

好的代码需要写三遍

1. 第一遍把功能实现出来 （问我自己的代码好不好？ 直接说不好。如果你的代码写得好，就不是graduate水平了，写得好就能找到工作了）
2. 第二遍对着SOLID 
    （主要是Single Responsibility 去review 代码，重新写一遍）  
    （不是对着来Single Responsibility 去对着来自圆其说）
    （自我否定 - 问自己的代码好不好，重新写一遍，肯定写不好的；）
    （不好，哪里可以提升？Single Responsibility）
3. 再写  `*n` 遍
	（问我的代码好不好？ 不好，哪里可以提升？问自己solid）


有的同学问用ai来纠正。但是因为ai的使用者本身需要达到能够识别SOLID的好的代码，然而进行一个训练，但是因为ai使用者本身就没有这个能力，所以没办法把握这个ai回答质量。


junior要花更多时间去，“想”写好的代码。以10等份去拆分整个工作时间。 8:2 ， 8等份是你想代码的时间，远比2等份你们执行写代码这件事的时间是多得多

没有找到好的工作之前，一些项目是要珍惜的



面试要体现出来

在React之前就有想过把这个事情给普及，但是科技的限制，没办法把声明式范式给普及。
![](https://i.imgur.com/a8ZVitu.png)


这个是合法的valina JavaScript，利用DOM去写的

![](https://i.imgur.com/ML3E7wE.png)



但是在我们的IDe里面可以看到，这样的代码是什么？
但是这样写代码是有问题的。

![](https://i.imgur.com/WDO2VsU.png)

在JS里面，`<div>...</div>` 是一个string，但是它是一个html的元素。导致可读性不好，加上， `<div>...</div>` 是字符串，导致可维护性不好。

我们实际期望是 一个 html的元素，但我们写的是JavaScript的字符串，这导致混乱。expectation is not the same reality 。

也有人尝试开发插件，如果用字符串去模拟html，然后给点高亮功能，但这个长期很难发展。


#### ES6的崛起

在ES6之前，没有template string，龙哥说他们是这样写代码

![](https://i.imgur.com/a1nI6h5.png)


有的同学想这样写代码，
![](https://i.imgur.com/1WwnoZB.png)

但是这个缺点在于，JavaScript编译器不认识这样的代码。

由此可见，JavaScript所有的APIs 都是为了操作HTML来写的；这一特性确定了JavaScript的天生短板-和HTML绑死了。
JavaScript它本是就是一个编程语言，甚至不包含以下这些api，这些api是后面发展出来的，这也是为什么它要写这些api来操作HTML。

```js
document.getElementById()
document.getElementById().click = function (){}
```

JavaScript本身是一个编程语言的意思，它具备这些  construct: `var` , `function () {}`, `if () {}`, `for () {}`
![](https://i.imgur.com/jUVHDA4.png)



为什么JavaScript没有version这一说法。ES6是一个提议，一个规范，一个标准。ECMA国际标准组织,没有执行权，只有提议权



自从ES6出来之后，程序员要死磕ES6；不管那些浏览器是否兼容，无论如何都要死磕es6，这也导致一个问题，该怎么去维护一些老的代码，大量程序员都在写es6的代码。

所以这个时候出现了转换器 （es6 ->es5)，把新的代码转换成老的代码，因为我们要死磕es6


计算机只能解读0和1这样的二进制代码。我们平时使用的编程语言，如C、C++、Java等，计算机其实是看不懂的。这就是为什么我们需要编译器(compiler)，它的作用就是把这些高级语言代码转换成计算机能理解的二进制代码。

同样的道理，为了能够使用ES6的新特性，我们需要把ES6代码编译成ES5代码。虽然JavaScript本身是一个解释型语言，通过浏览器内置的JavaScript解释器就可以直接运行，但是考虑到像IE6这样的老旧浏览器不支持ES6语法，我们就需要使用Babel这样的工具来进行转换，把ES6代码转换成这些浏览器能够理解的ES5代码。

![](https://i.imgur.com/XBwm4Ml.png)

浏览器的兼容性问题一直是前端开发中的一大痛点。不同浏览器厂商对JavaScript特性的支持程度不同，有的浏览器支持最新的ES6特性，而有的浏览器（特别是一些老旧的浏览器）仍然停留在ES5阶段。这就迫使开发者要么放弃使用新特性，要么需要为不同浏览器写不同版本的代码。

这种兼容性问题严重限制了JavaScript的发展空间。开发者即使想要使用ES6提供的新特性来提高开发效率、改善代码质量，也不得不考虑兼容性问题。这导致JavaScript的创新和进步受到了很大的阻碍，开发者不得不在新特性和兼容性之间做出妥协。

转换器（如Babel）的出现很好地解决了这个问题。它允许开发者放心地使用最新的ES6特性进行开发，然后通过转换器将代码自动转换为ES5版本，以确保在各种浏览器中都能正常运行。这种方案既保证了代码的兼容性，又让开发者能够享受到新特性带来的便利，可以说是解决了前端开发中的一个重要难题。



比如说在javascript写html
![](https://i.imgur.com/kU5V1Up.png)


Babel的出现让我们能够编写更现代化的JavaScript代码。它不仅能将ES6代码转换为ES5以实现浏览器兼容性，还能让我们在JavaScript中直接编写类似HTML的JSX语法。这种看似"不合法"的JavaScript代码（比如在JS中直接写HTML标签），通过Babel的转换后就变成了浏览器可以理解的标准JavaScript代码。这大大提升了开发体验和效率，让我们能够更直观地编写UI相关的代码。


React给我们提供了一个专门的编译手段，让我们能够更好地实现组件化和模块化开发。这里需要注意的是，组件化不仅仅是简单地把一个function抽出来那么简单。

让我们用建造一座跨海大桥来打个比方：当我们要建造一座大桥时，整个工程会被分解成多个模块，比如把桥梁的螺丝制造交给河南的专业公司，把桥架的生产分配给山东的专业厂商等。每个公司专注于自己的专业领域，最终所有的部件组合在一起，形成一座完整的大桥。这就像React中的组件化和模块化开发 - 我们把复杂的应用拆分成独立的、可重用的组件，每个组件负责特定的功能，最终组合成一个完整的应用。


![](https://i.imgur.com/0OCkfYz.png)


我们这里出来了打包器的概念

```
import sum from './sum'
...
```

它一定是找到相应的文件，把他们打包起来

![](https://i.imgur.com/tboGky6.png)

Webpack 是一个打包工具，它的工作原理与 Docker 容器化技术完全不同。Webpack 的主要功能是根据代码中的 import/require 语句，从指定的入口文件开始，顺着文件之间的依赖关系，到对应的文件路径下找到所有相关的模块文件，然后将它们打包合并成一个或多个 bundle 文件。这个过程就像一个文件收集器，简单地将分散的模块文件组合在一起，而不涉及环境隔离或虚拟化等容器技术的特性。

![](https://i.imgur.com/cX26Ss5.png)



Webpack 会将所有的 JavaScript 文件打包成一个单独的文件（通常命名为 main.js）。当浏览器加载页面时，它只需要加载这一个打包后的文件，而不是分别加载多个独立的 .js 文件。

这个打包后的文件会包含项目中所有的 JavaScript 代码，经过压缩和混淆处理，变得难以阅读 - 可能会有上万行代码。这样做的好处是减少了浏览器需要发起的 HTTP 请求数量，提高了页面加载性能。





### 为什么我们需要Vite？

- React
    一个专注于 UI 的 JavaScript 库
    官方文档：https://react.dev/
- Babel
    核心：编译
    让现代 JavaScript 兼容所有浏览器，引入非标准化的 JavaScript 版本。
    官方文档：https://babeljs.io/docs/
- Webpack
    核心：模块化
    模块捆绑器和任务运行
    官方文档：https://webpack.js.org/concepts/

💡 老师建议：了解 Babel 和 Webpack 背后的理论，即：编译和模块化，而不是局限于工具的学

#### 脚手架与React思维方式

在开始使用脚手架之前，我们需要先理解React的思维方式，而不仅仅是学习React的语法。

关键点：
1. 在开始编写代码前，先思考整体架构和组件设计
2. 理解龙哥的编程思维和方法论，而不是简单地复制代码
3. 培养独立思考的能力 - 如果遇到问题，要多问"为什么"，而不是只关注"怎么做"
4. 记住"能工作"只是最基本的要求，代码的可维护性和可扩展性更为重要
5. 如果因为不熟练而需要更多时间，这是正常的学习过程

让我们先看看在没有脚手架的情况下，如何编写React代码：

![](https://i.imgur.com/853OOmB.png)


但是因为我们是JavaScript程序员，所以我们写个main.js,死磕javascript

![](https://i.imgur.com/c2QRcJH.png)


典型的命名重名问题 textNode

![](https://i.imgur.com/UuGll3N.png)


然而，在大型项目中，仅仅依靠简单的命名方式是无法保证代码的可维护性的。
当代码量达到上万行时，变量和函数重名的问题会变得非常普遍。
因此，我们需要制定严格的命名规范和约定，来避免命名冲突并提高代码的可读性。


![](https://i.imgur.com/HSUDRfs.png)

让我们思考一个细节问题：如果变量名 heading 需要改成 h1，会发生什么？
这个简单的改动可能会影响到代码的多个地方。

这让我们想到现实生活中的一个类似情况：
当我们有多个杯子时，我们会说：
- "厨房里的杯子"
- "卧室里的杯子" 

虽然都是"杯子"，但通过所在的空间来区分它们的用途和身份。这就是命名空间(namespace)的概念。

命名空间就像是一个容器，它把相关的事物组织在一起。就像"厨房"这个空间包含了所有与厨房相关的物品。

在JavaScript中，我们也需要这样的概念来组织和隔离代码。我们需要一种方式把相关的代码放在一个独立的区域内。

而function就提供了这样的功能 - 它不仅是一个代码块，更是一个作用域(scope)，能够有效地隔离和组织相关的代码。


![](https://i.imgur.com/LscMWhP.png)

这就是为什么一个好的代码需要经过三次重写和优化:

第一遍：实现基本功能，让代码能够工作
第二遍：重构代码结构，提高可读性和可维护性
第三遍：优化细节，完善命名和注释

就像整理抽屉一样，我们需要:
1. 先把东西分类放好
2. 再细分每个类别
3. 最后给每个物品贴上清晰的标签

这样不仅能让代码更有条理，也方便后期维护和扩展。

有同学说说 textNodeNew 并不是不对，而不是最优解。

`textNode = document.createTexNode('Welcome to my..')`


贴标签怎么贴？
![](https://i.imgur.com/pTZPxKU.png)

或者取一个名字
![](https://i.imgur.com/gVaij5H.png)



那么也有人会质疑，为什么要把heading写成一个方法？
我们可能会尝试回答：因为我们遇到textNode的重名问题，所以我们开始写function来划分区域。

这样的确解答了问题，但是我们只解决了技术问题，没有解决是否符合人类思考方式的问题。我们把heading写成了heading()，但heading这个词本身就不应该成为一个方法（function），只是为了解决技术问题，我们不得不把heading写成一个方法（function）。
如果我们用以上的回答，那就意味着我们只是在用技术结果来回答技术原因，仅仅在回答和解释技术问题。这不是一个好的回答。这也是为什么很多IT从业者不擅长解答来自非it人的问题。
![](https://i.imgur.com/JOVRcXb.png)

但是技术经验相对短暂，而人类的生活经验则有很长时间的积累。

![](https://i.imgur.com/kgtybLD.png)

但我们把方法给去掉 `()`，我们javascript又不能编译了

因此，我们需要对自己的代码保持自我否定和批判态度，承认这段代码还需要改进。让我们从重命名开始 - 当我们在"做一件事"时，函数名不能仅仅是一个名词，而应该是动词或动词短语。这个过程告诉我们，编写代码不仅仅是让它能够运行那么简单，而是一个需要不断反思和关注细节的过程。

接着，我们再次否定这个代码，我们说这个代码不够declaretive，不够声明范式导致不可读。

写代码的良好习惯 - 看到一个累赘，开始思考，需要root吗？

![](https://i.imgur.com/DeOPJxQ.png)


没有养成这个良好习惯看似只是微小的差距，但背后需要付出巨大的努力来弥补。这种思维和习惯上的差异会带来显著影响。

让代码能够正常工作只是最基本的要求。

在箭头函数中，如果函数体只有一行表达式，我们可以省略 return 关键字，代码会更加简洁。

![](https://i.imgur.com/unF8QoD.png)


![](https://i.imgur.com/6FgcWZB.png)

刷新的时候，果不其然地马上就不能工作了。

![](https://i.imgur.com/92SYTGy.png)

<`就不认识了


Babel转换器就有用了
![](https://i.imgur.com/JN8O5E4.png)


把这个复制进来，也发现不能运行。
这里引出写代码的一个方式方法


get hands dirty
error-driven, bug-driven



这个是最短的路，最捷径的路，让代码跑起来 （copy-paste）
然后通过不断反思，让代码不断地变好
而不是从网上搜一个现成答案，跟着他们的思路一步步坐下来
你写代码永远不是别人教你怎么写的，

比如说接到第一个卡，自己不会写不会处理，该怎么办？

要想一个办法，即使这个代码你完全不会，从来没有听说过，你也能把它写出来

get hands dirty， 看它报什么错



![](https://i.imgur.com/ZWgiOLh.png)

很多同学看不懂报错就立马Google 一下，或者Chatgpt一下。这是他们的解决方案。

龙哥说不要这么做。我们需要学会从有限的错误信息，找到无限点。

我们借用仅有的报错信息


```
Uncaught SyntaxError: Cannot use import statement outside a module (at main.js:1:1)
```



我们回到自己的代码。
![](https://i.imgur.com/zUaz8If.png)

看到了这个模块化，我们就想到了webpack





龙哥提倡一个点：学海无涯，回头是岸。
倒不是说不要去学习，而是主动去学习，可能永远学不完，那么这个时候要改变一下策略。由于许多时候，“被动学习”是让学习更有目标和更有专注，学了马上用。




![](https://i.imgur.com/Brp7g1k.png)


我们不得不去学习webpack，因为我们看到Module这一个词

那么，我们的学习方法该怎么去学？
- 去YouTube上一节课
- 去匠人报一个1v1

都可以，但是得考虑到我们的学习不是一次性的。即可能我们在一个办公室里，周围都是同事组长老板，不可能在光天化日之下去打开Youtube

那么，我们学习所有东西，都必须从官方文档去学习（阅读是很重要的）



![](https://i.imgur.com/vkP1JOp.png)

当你遇到一个新的名词时候，去学习一下



![](https://i.imgur.com/rIKbrQI.png)



简单地扫一下，知道是一个local server


这个webpack帮你创建了很多文件



![](https://i.imgur.com/ZNs2VeI.png)

一个个文件去看，把webpack学习一遍



![](https://i.imgur.com/CPdD8kp.png)


要开始使用Babel，我们需要在webpack.config.js文件中的'module'部分进行配置。

配置完成后，我们需要将代码从main.js移动到index.js中，这是Webpack模块打包过程的一部分。

Webpack需要大量的配置才能正常工作。当我们完成这些繁琐的配置过程后，就能理解为什么许多开发者更倾向于使用Vite作为构建工具了 - 因为Vite能达到相似的效果，却需要少得多的配置工作。










